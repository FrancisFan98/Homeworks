			   __________________

			    LAB 02 QUESTIONS
			   __________________


- Name: (Zhenyu Fan)
- NetID: (fanxx495)

Answer the questions below according to the lab specification. Write
your answers directly in this text file and submit it to complete the
lab.


PROBLEM 1: last_elem recursive function
=======================================

(A)
~~~

  Start the OCaml REPL in the `lab02-code' directory and load the
  `rec_funcs.ml' source file with a `#use' directive as shown.

  ,----
  | > ocaml
  | 	OCaml version 4.06.0
  | 
  | # #use "rec_funcs.ml";;
  | val last_elem : 'a list -> 'a = <fun>
  | val elems_outside : int -> int -> 'a list -> 'a list = <fun>
  | #
  `----

  The first function loaded from the source file is called `last_elem'.

  Describe in words the type of `last_elem' :
  - What kind of argument does it take?   
  - What type does it return? 
  - What does the 'a notation mean?

  It takes a list and output something of type of the element in the list, ‘a stand for any type. 

  

(B)
~~~

  Call `last_elem' on several input lists in the REPL and show the
  return values.
  - Make sure to call the function on an empty list and report what
    happens.
  - Make sure to use several different types of lists (int list, string
    list) and a few different lengths.

  Paste your REPL transcript below AND describe in a line or two what
  the function does.

l  # last_elem [1;2;3];;
  - : int = 3
  #  last_elem ["1"; "2"; "3"];;
  - : string = "3"


(C)
~~~

  Examine the definition of `last_elem' in `rec_funcs.ml'. Study how it
  operates carefully to gain insight on recursive functions.

  Add comments in your own words that describe line-by-line how the
  function operates. Paste your commented version of the code below.

let rec last_elem list =
  if list = [] then
    raise (Failure "No last element in an empty list")  (*if list is empty report error*)
  else
    let elem = List.hd list in
    let rest = List.tl list in
    if rest = [] then    (*run the same recursion function on the tail of the list till the tail is empty and return head as the last element*)
      elem
    else
      last_elem rest
;;


PROBLEM 2: elems_outside with recursive helper function
=======================================================

(A)
~~~

  The other function loaded by `rec_funcs.ml' is called `elems_outside'.
  As before, describe it's type.
  - How many parameters does it take and what type are they?
  - What type does it return?

  3 int int and list 
  output something of type of the element in the list
  


(B)
~~~

  In the REPL, call `elems_outside' on several lengths and types of
  lists. Show the results generated by these calls by pasting your REPL
  session below. Describe what the function appears to be doing.

  return all the elements outside of the index range
  # elems_outside 1 2 [1;2;3;4;5];;
- : int list = [1; 4; 5]


(C)
~~~

  Examine the definition of `elems_outside' in `rec_funcs.ml'. Study how
  it operates carefully to gain insight on recursive functions.

  Add comments in your own words that describe line-by-line how the
  function operates. Paste your commented version of the code below.

  let elems_outside start stop list =
  let rec helper pos lst =
    if lst=[] then              (*if lst is empty return empty list*)
      []     								
    else if start<=pos && pos<=stop then
      helper (pos+1) (List.tl lst)            (*if index is in the index range, skip this element*)
    else
      let elem = List.hd lst in
      let rest = List.tl lst in            (*if index is not in the index range, append the first element into the output and run the helper function on the rest of the list*)
      let result =  helper (pos+1) rest in
      elem :: result
  in
  helper 0 list
;;


Problem 3
=========

(A)
~~~

  Examine the two functions provided in `sorting.ml': `sorted_insert'
  and `sort'. Describe the parameter and return types for both
  functions. Based on the comments and source code, determine their
  purpose.

  
  sorted_insert takes a value of random type and a list of the first variable’s type and return a list of that type. Inserting a element into a sorted list

  sort take a list of a random type list and return a list of that type. Sort a list
  


  


(B)
~~~

  The code provided for this problem is an adaptation of code from the
  Ocaml System Manual Section 1.2 which is here
  [http://caml.inria.fr/pub/docs/manual-ocaml/coreexamples.html#sec9]

  The original version looks like this:
  ,----
  | let rec sort lst =
  |   match lst with
  |     [] -> []
  |   | head :: tail -> insert head (sort tail)
  | and insert elt lst =
  |   match lst with
  |     [] -> [elt]
  |   | head :: tail -> if elt <= head then elt :: lst else head :: insert elt tail
  | ;;
  `----

  The version in `sorting.ml' has been re-written so that it is somewhat
  more verbose but potentially easier for a novice to understand.
  - Ordering of the functions is reversed so that insertion is defined
    prior to sorting
  - Two separate "let" bindings are used rather than a joint "let/and"
    binding
  - Pattern matching via "match" is replaced with "if/else" statements
  - Destructure binding is replaced with explicit calls to List.hd and
    List.tl

  All of the above concepts will eventually be covered and it does not
  hurt one to look ahead a bit.

  COMPARE the code in `sorting.ml' to the original OSM version above.
  Make some observations about how the syntax associated with the
  "match" statement must work.

  match the specific variable to different patterns and therefore execute different statements
